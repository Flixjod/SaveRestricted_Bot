# Don't Remove Credit Tg - @FLiX_LY
# Ask Doubt on telegram @FLiX_LY

import os, re, time, pytz, psutil, aiofiles, logging, asyncio, platform
from datetime import datetime, timedelta

from telegraph import Telegraph
from pyrogram import Client, filters
from pyrogram.types import Message, CallbackQuery, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.errors import UserIsBlocked, PeerIdInvalid

from config import OWNER_ID, TOKEN_API_URL, TOKEN_API_KEY
from database.db import database
from FLiX.Save import format_duration

logger = logging.getLogger(__name__)

telegraph = Telegraph()
telegraph.create_account(short_name="SaveRest")



@Client.on_message(filters.command("setplan") & filters.private, group=3)
async def set_plan(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        parts = message.text.strip().split()
        if len(parts) != 5:
            return await client.send_message(
                message.chat.id,
                "‚ùó **Incorrect Usage!**\n\n"
                "Please use the correct format:\n\n"
                "üìå `/setplan plan_name value unit price`\n\n"
                "**Examples:**\n"
                "`/setplan vip 30 days 99`\n"
                "`/setplan elite 1 none 499`  ‚Üí (Lifetime Plan)",
                reply_to_message_id=message.id
            )

        _, plan_name, raw_value, raw_unit, raw_price = parts

        unit_map = {
            "day": "days", "days": "days",
            "hour": "hours", "hours": "hours",
            "minute": "minutes", "minutes": "minutes",
            "none": "none"
        }
        unit = unit_map.get(raw_unit.lower())
        if not unit:
            raise ValueError("Invalid unit. Use: day(s), hour(s), minute(s), or none.")

        if unit == "none":
            duration = None
        else:
            duration = int(raw_value)
            if duration < 0:
                raise ValueError("Duration cannot be negative.")

        price = float(raw_price) if "." in raw_price else int(raw_price)
        if price < 0:
            raise ValueError("Price cannot be negative.")

        # Check if plan already exists
        existing = await database.plans.find_one({"plan": plan_name})
        if existing:
            existing_duration = existing.get("duration")
            existing_unit = existing.get("unit", "none")
            existing_price = existing.get("price", 0)

            old_duration_display = "‚ôæÔ∏è Lifetime" if existing_unit == "none" else f"{existing_duration} {existing_unit}"
            old_price_display = f"‚Çπ{existing_price:.2f}".rstrip('0').rstrip('.') if isinstance(existing_price, float) else f"‚Çπ{existing_price}"

            keyboard = ReplyKeyboardMarkup([["‚úÖ ùó¨ùó≤ùòÄ", "‚ùå ùó°ùóº", "üóëÔ∏è ùóóùó≤ùóπùó≤ùòÅùó≤"]], one_time_keyboard=True, resize_keyboard=True)

            prompt = await client.send_message(
                message.chat.id,
                f"‚ö†Ô∏è **Plan Already Exists!**\n\n"
                f"Here are the current details for `{plan_name}`:\n"
                f"‚Ä¢ **Duration:** *{old_duration_display}*\n"
                f"‚Ä¢ **Price:** `{old_price_display}`\n\n"
                f"Would you like to **update** this plan with the new values?",
                reply_markup=keyboard,
                reply_to_message_id=message.id
            )

            try:
                response: Message = await client.wait_for_message(
                    chat_id=message.chat.id,
                    timeout=75,
                    filters=filters.text & filters.user(message.from_user.id)
                )
            except asyncio.TimeoutError:
                await prompt.delete()
                return await client.send_message(
                    message.chat.id,
                    "‚åõ ùóßùó∂ùó∫ùó≤ùóºùòÇùòÅ! ùó¨ùóºùòÇ ùó±ùó∂ùó±ùóª‚ÄôùòÅ ùóøùó≤ùòÄùóΩùóºùóªùó±. ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÅùóøùòÜ ùóÆùó¥ùóÆùó∂ùóª.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )

            user_input = response.text.strip().replace("‚úÖ ùó¨ùó≤ùòÄ", "yes").replace("‚ùå ùó°ùóº", "no").replace("üóëÔ∏è ùóóùó≤ùóπùó≤ùòÅùó≤", "delete").lower()
            await prompt.delete()
            await response.delete()

            if user_input == "no":
                return await client.send_message(
                    message.chat.id,
                    "**‚ùå Plan update cancelled.**",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            elif user_input == "delete":
                await database.plans.delete_one({"plan": plan_name})
                return await client.send_message(
                    message.chat.id,
                    f"üóëÔ∏è Plan `{plan_name}` has been deleted.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            elif user_input == "yes":
                # Proceed with updating the plan
                await database.plans.update_one(
                    {"plan": plan_name},
                    {"$set": {
                        "plan": plan_name,
                        "duration": duration,
                        "unit": unit,
                        "price": price
                    }},
                    upsert=True
                )

                duration_display = "‚ôæÔ∏è Lifetime" if unit == "none" else f"{duration} {unit}"
                price_display = f"‚Çπ{price:.2f}".rstrip('0').rstrip('.') if isinstance(price, float) else f"‚Çπ{price}"

                return await client.send_message(
                    message.chat.id,
                    f"‚úÖ **Plan Updated Successfully!**\n\n"
                    f"‚Ä¢ **Plan:** `{plan_name}`\n"
                    f"‚Ä¢ **Duration:** *{duration_display}*\n"
                    f"‚Ä¢ **Price:** `{price_display}`",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            else:
                # If invalid response
                return await client.send_message(
                    message.chat.id,
                    "‚ùó Invalid response! Please choose either **Yes**, **No**, or **Delete**.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )

        # If no existing plan, simply create or update the new plan
        await database.plans.update_one(
            {"plan": plan_name},
            {"$set": {
                "plan": plan_name,
                "duration": duration,
                "unit": unit,
                "price": price
            }},
            upsert=True
        )

        duration_display = "‚ôæÔ∏è Lifetime" if unit == "none" else f"{duration} {unit}"
        price_display = f"‚Çπ{price:.2f}".rstrip('0').rstrip('.') if isinstance(price, float) else f"‚Çπ{price}"

        await client.send_message(
            message.chat.id,
            f"‚úÖ **Plan Saved Successfully!**\n\n"
            f"‚Ä¢ **Plan:** `{plan_name}`\n"
            f"‚Ä¢ **Duration:** *{duration_display}*\n"
            f"‚Ä¢ **Price:** `{price_display}`",
            reply_to_message_id=message.id,
            reply_markup=ReplyKeyboardRemove()
        )

    except Exception as e:
        await client.send_message(
            message.chat.id,
            f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n`{e}`",
            reply_to_message_id=message.id,
            reply_markup=ReplyKeyboardRemove()
        )


# Grant Premium Access
@Client.on_message(filters.command("upgrade") & filters.private)
async def upgrade_to_premium(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        parts = message.text.strip().split()
        if len(parts) < 3:
            return await client.send_message(
                message.chat.id,
                "‚ö°Ô∏è ùó®ùóΩùó¥ùóøùóÆùó±ùó≤ ùóñùóºùó∫ùó∫ùóÆùóªùó± ùó®ùòÄùóÆùó¥ùó≤\n\n"
                "‚û§ `/upgrade user_id plan_name`\n"
                "‚û§ `/upgrade user_id value [unit (days/hours/minutes/lifetime)]`\n\n"
                "üìù ùóòùòÖùóÆùó∫ùóΩùóπùó≤ùòÄ:\n"
                "‚îú `/upgrade 1234567890 vip`\n"
                "‚îî `/upgrade 1234567890 30 days`\n\n"
                "üí° ùóßùó∂ùóΩ: Use a preset plan name or set a custom duration with unit.",
                reply_to_message_id=message.id
            )

        user_id = int(parts[1])
        now_utc = datetime.now(pytz.utc)
        ist = pytz.timezone("Asia/Kolkata")
        is_preset = False
        is_lifetime = False
        is_extension = False
        is_reset = False

        # Check if it's a predefined plan or raw duration
        if len(parts) == 3:
            plan_name = parts[2]
            plan = await database.plans.find_one({'plan': plan_name})
            if not plan:
                return await client.send_message(
                    message.chat.id,
                    f"‚ùå Plan `{plan_name}` not found in database.",
                    reply_to_message_id=message.id
                )
            value = plan['duration']
            unit = plan['unit']
            is_preset  = True
            is_lifetime = (unit == 'none')

        else:
            value = int(parts[2])
            unit_input = parts[3].lower()
            unit_map = {
                "day": "days", "days": "days",
                "hour": "hours", "hours": "hours",
                "minute": "minutes", "minutes": "minutes",
                "lifetime": "none"
            }
            unit = unit_map.get(unit_input)
            is_lifetime = (unit == "none")
            plan_name = "Custom"
            if not unit:
                return await client.send_message(
                    message.chat.id,
                    "**Invalid time unit. Use 'days', 'hours', or 'minutes'.**",
                    reply_to_message_id=message.id
                )

        # Get user info from database
        user = await database.users.find_one({'user_id': user_id})
        if not user:
            return await client.send_message(
                message.chat.id,
                f"‚ùå User `{user_id}` not found in database.",
                reply_to_message_id=message.id
            )
        user_info = await client.get_users(user_id)

        # Backend Process
        plan_data = user.get('plan', {})
        existing_exp = plan_data.get('expiration_at')
        started_at = plan_data.get('started_at') or now_utc
        existing_preset = plan_data.get('preset') or "Custom"

        # Normalize existing_exp to datetime
        if isinstance(existing_exp, str):
            existing_exp = datetime.fromisoformat(existing_exp)
        if existing_exp and existing_exp.tzinfo is None:
            existing_exp = existing_exp.replace(tzinfo=pytz.utc)

        has_active_plan = existing_exp and existing_exp > now_utc
        has_lifetime_plan = existing_exp is None and plan_data.get("type") == "premium"
        old_plan_display = None

        if has_active_plan:
            expiry_ist = existing_exp.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p` (IST)")
            old_remaining = format_duration(existing_exp - now_utc)
            old_plan_display = (
                f"üìÜ **Old Plan:** {existing_preset}\n"
                f"‚è≥ **Old Remaining:** {old_remaining}\n"
                f"üïò **Expires At:** {expiry_ist}"
            )

        elif has_lifetime_plan:
            old_plan_display = f"üìÜ **Current Plan:** {existing_preset}, ‚ôæÔ∏è"

        new_plan_display = (
            f"`{plan_name}`, ‚ôæÔ∏è" if is_lifetime else
            f"`{plan_name}`, *{value} {unit}*"
        )

        # Handle confirmation
        if has_lifetime_plan:
            confirm = await client.send_message(
                message.chat.id,
                f"‚ö†Ô∏è ùóßùóµùó∂ùòÄ ùòÇùòÄùó≤ùóø ùóµùóÆùòÄ ùóÆ ‚ôæÔ∏è ùóüùó∂ùó≥ùó≤ùòÅùó∂ùó∫ùó≤ ùóΩùóπùóÆùóª.\n\n"
                f"üë§ **User ID:** `{user_id}`\n"
                f"{old_plan_display}\n\n"
                f"üÜï **New Plan:** {new_plan_display}\n\n"
                f"‚ö†Ô∏è Type or press `ùó•ùó≤ùòÄùó≤ùòÅ` to continue, or `ùóñùóÆùóªùó∞ùó≤ùóπ` to abort.",
                reply_to_message_id=message.id,
                reply_markup=ReplyKeyboardMarkup([["‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ", "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"]], one_time_keyboard=True, resize_keyboard=True),
            )
            try:
                response: Message = await client.wait_for_message(
                    chat_id=message.chat.id,
                    timeout=75,
                    filters=filters.text & filters.user(message.from_user.id)
                )
            except asyncio.TimeoutError:
                await client.delete_messages(message.chat.id, [confirm.id])
                return await client.send_message(
                    message.chat.id,
                    "‚åõ ùóßùó∂ùó∫ùó≤ùóºùòÇùòÅ! ùó¨ùóºùòÇ ùó±ùó∂ùó±ùóª‚ÄôùòÅ ùóøùó≤ùòÄùóΩùóºùóªùó±. ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÅùóøùòÜ ùóÆùó¥ùóÆùó∂ùóª.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )

            await client.delete_messages(
                message.chat.id,
                [confirm.id, response.id]
            )
            choice = response.text.strip().lower()
            if choice in ["cancel", "ùóñùóÆùóªùó∞ùó≤ùóπ", "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"]:
                return await client.send_message(
                    message.chat.id,
                    "‚úñÔ∏è ùó¢ùóΩùó≤ùóøùóÆùòÅùó∂ùóºùóª ùó∞ùóÆùóªùó∞ùó≤ùóπùóπùó≤ùó±.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            if choice not in ["reset", "ùó•ùó≤ùòÄùó≤ùòÅ", "‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ"]:
                return await client.send_message(
                    message.chat.id,
                    "‚ùå Invalid input. Only `ùó•ùó≤ùòÄùó≤ùòÅ` is allowed.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            is_reset = choice in ["reset", "ùó•ùó≤ùòÄùó≤ùòÅ", "‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ"]

        elif has_active_plan:
            confirm = await client.send_message(
                message.chat.id,
                f"‚ö†Ô∏è ùóßùóµùó∂ùòÄ ùòÇùòÄùó≤ùóø ùóµùóÆùòÄ ùóÆùóª ùóÆùó∞ùòÅùó∂ùòÉùó≤ ùóΩùóøùó≤ùó∫ùó∂ùòÇùó∫ ùóΩùóπùóÆùóª.\n\n"
                f"üë§ **User ID:** `{user_id}`\n"
                f"{old_plan_display}\n\n"
                f"üÜï **New Plan:** {new_plan_display}\n\n"
                f"‚ú≥Ô∏è Type or press `ùó•ùó≤ùòÄùó≤ùòÅ` to reset, or `ùóòùòÖùòÅùó≤ùóªùó±` to add more time.",
                reply_to_message_id=message.id,
                reply_markup=ReplyKeyboardMarkup([["‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ", "‚è© ùóòùòÖùòÅùó≤ùóªùó±"], ["‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"]], one_time_keyboard=True, resize_keyboard=True),
            )
            try:
                response: Message = await client.wait_for_message(
                    chat_id=message.chat.id,
                    timeout=75,
                    filters=filters.text & filters.user(message.from_user.id)
                )
            except asyncio.TimeoutError:
                await client.delete_messages(message.chat.id, [confirm.id])
                return await client.send_message(
                    message.chat.id,
                    "‚åõ ùóßùó∂ùó∫ùó≤ùóºùòÇùòÅ! ùó¨ùóºùòÇ ùó±ùó∂ùó±ùóª‚ÄôùòÅ ùóøùó≤ùòÄùóΩùóºùóªùó±. ùó£ùóπùó≤ùóÆùòÄùó≤ ùòÅùóøùòÜ ùóÆùó¥ùóÆùó∂ùóª.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )

            await client.delete_messages(
                message.chat.id,
                [confirm.id, response.id]
            )
            choice = response.text.strip().lower()
            if choice in ["cancel", "ùóñùóÆùóªùó∞ùó≤ùóπ", "‚ùå ùóñùóÆùóªùó∞ùó≤ùóπ"]:
                return await client.send_message(
                    message.chat.id,
                    "‚úñÔ∏è ùó¢ùóΩùó≤ùóøùóÆùòÅùó∂ùóºùóª ùó∞ùóÆùóªùó∞ùó≤ùóπùóπùó≤ùó±.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            if choice not in ["reset", "ùó•ùó≤ùòÄùó≤ùòÅ", "‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ", "extend", "ùóòùòÖùòÅùó≤ùóªùó±", "‚è© ùóòùòÖùòÅùó≤ùóªùó±"]:
                return await client.send_message(
                    message.chat.id,
                    "‚ùå Invalid input. Use the buttons or type `ùó•ùó≤ùòÄùó≤ùòÅ`, `ùóòùòÖùòÅùó≤ùóªùó±`, or `ùóñùóÆùóªùó∞ùó≤ùóπ`.",
                    reply_to_message_id=message.id,
                    reply_markup=ReplyKeyboardRemove()
                )
            is_reset = choice in ["reset", "ùó•ùó≤ùòÄùó≤ùòÅ", "‚ôªÔ∏è ùó•ùó≤ùòÄùó≤ùòÅ"]
            is_extension = choice in ["extend", "ùóòùòÖùòÅùó≤ùóªùó±", "‚è© ùóòùòÖùòÅùó≤ùóªùó±"]

        # Calculate new expiration
        if is_lifetime:
            expiration_utc = None
            started_at = now_utc
        else:
            delta = timedelta(**{unit: value})
            if is_extension and existing_exp:
                expiration_utc = existing_exp + delta
            else:
                expiration_utc = now_utc + delta
                started_at = now_utc

        # Convert times for display
        started_time_ist = started_at.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)" if started_at else "N/A"
        expiry_time_ist = "**Never**" if expiration_utc is None else \
            expiration_utc.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)"
        plan_info = (
            f"`{plan_name}`, ‚ôæÔ∏è" if is_lifetime else f"`{plan_name}`, *{value} {unit}*"
        )

        # Update database
        await database.users.update_one(
            {'user_id': user_id},
            {'$set': {
                'plan': {
                    'type': 'premium',
                    'preset': plan_name if is_preset else None,
                    'started_at': started_at,
                    'expiration_at': expiration_utc,
                    'upgrade_by': message.from_user.id
                }
            }},
            upsert=True
        )

        # Text to admin & user
        if is_extension:
            admin_text = (
                f"üéâ ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùóòùòÖùòÅùó≤ùóªùó±ùó≤ùó± ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ ‚úÖ\n\n"
                f"üë§ **User:** [{user_info.first_name}](tg://user?id={user_info.id})\n"
                f"‚ö° **User ID:** `{user_id}`\n"
                f"üïí **Old Remaining:** {old_remaining}\n"
                f"‚ûï **Extended With:** {plan_info}\n\n"
                f"‚è≥ **Joined:** {started_time_ist}\n"
                f"‚åõ **Expires:** {expiry_time_ist}"
            )
            user_text = (
                "üîî ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùóòùòÖùòÅùó≤ùóªùó±ùó≤ùó±!\n\n"
                f"üëã Hi [{user_info.first_name}](tg://user?id={user_info.id}),\n"
                f"**Your premium has been extended. Enjoy!** ‚ú®üéâ\n\n"
                f"üïí **Old Remaining:** {old_remaining}\n"
                f"‚ûï **Added:** {plan_info}\n"
                f"‚åõ **New Expiry:** {expiry_time_ist}"
            )
        elif is_reset:
            admin_text = (
                f"üîÅ ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó•ùó≤ùòÄùó≤ùòÅ/ùó•ùó≤ùóΩùóπùóÆùó∞ùó≤ùó± ‚úÖ\n\n"
                f"üë§ **User:** [{user_info.first_name}](tg://user?id={user_info.id})\n"
                f"‚ö° **User ID:** `{user_id}`\n"
                f"üÜï **New Plan:** {plan_info}\n\n"
                f"‚è≥ **Joining:** {started_time_ist}\n"
                f"‚åõ **Expires:** {expiry_time_ist}"
            )
            user_text = (
                "‚ôªÔ∏è ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó•ùó≤ùòÄùó≤ùòÅ/ùó•ùó≤ùóΩùóπùóÆùó∞ùó≤ùó±!\n\n"
                f"üëã Hi [{user_info.first_name}](tg://user?id={user_info.id}),\n"
                f"**Your plan has been reset with a new premium duration.**\n\n"
                f"üÜï **New Plan:** {plan_info}\n"
                f"‚åõ **Expires:** {expiry_time_ist}"
            )
        else:
            admin_text = (
                f"üéâ ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùóîùó∞ùòÅùó∂ùòÉùóÆùòÅùó≤ùó± ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ ‚úÖ\n\n"
                f"üë§ **User:** [{user_info.first_name}](tg://user?id={user_info.id})\n"
                f"‚ö° **User ID:** `{user_id}`\n"
                f"‚è∞ **Plan:** {plan_info}\n\n"
                f"‚è≥ **Joining:** {started_time_ist}\n"
                f"‚åõ **Expires:** {expiry_time_ist}"
            )
            user_text = (
                "‚ú® ùó™ùó≤ùóπùó∞ùóºùó∫ùó≤ ùòÅùóº ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫!\n\n"
                f"üëã Hi [{user_info.first_name}](tg://user?id={user_info.id}),\n"
                f"**Thank you for purchasing premium. Enjoy!** ‚ú®üéâ\n\n"
                f"‚è∞ **Plan:** {plan_info}\n"
                f"‚åõ **Expires:** {expiry_time_ist}"
            )

        # 1Ô∏è‚É£3Ô∏è‚É£ Send notifications
        await client.send_message(
            message.chat.id,
            admin_text,
            reply_to_message_id=message.id,
            reply_markup=ReplyKeyboardRemove(),
            disable_web_page_preview=True
        )
        await client.send_message(
            user_id,
            user_text,
            disable_web_page_preview=True
        )


    except ValueError:
        await client.send_message(
            message.chat.id,
            "‚ùå **Invalid input. Use:** `/upgrade user_id plan` or `/upgrade user_id value unit`",
            reply_to_message_id=message.id
        )
    except Exception as e:
        await client.send_message(
            message.chat.id,
            f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n`{e}`",
            reply_to_message_id=message.id
        )


# Premium User List
@Client.on_message(filters.command("count_pre") & filters.private, group=3)
async def check_premium_users(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        # Send temporary "Fetching..." message
        fetching_msg = await client.send_message(
            chat_id=message.chat.id,
            text="‚è≥ ùóôùó≤ùòÅùó∞ùóµùó∂ùóªùó¥ ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ ùóúùóªùó≥ùóº, ùóΩùóπùó≤ùóÆùòÄùó≤ ùòÑùóÆùó∂ùòÅ...",
            reply_to_message_id=message.id
        )

        if len(message.command) > 1:
            arg = message.command[1].strip()
            if not arg.isdigit():
                await fetching_msg.delete()
                await client.send_message(
                    chat_id=message.chat.id,
                    text="‚ö†Ô∏è ùóòùóøùóøùóºùóø:\n\nPlease provide a **valid numeric user ID** only.",
                    reply_to_message_id=message.id
                )
                return
            specific_user_id = int(arg)

            user_data = await database.users.find_one({'user_id': specific_user_id})
            if not user_data:
                await fetching_msg.delete()
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"‚ùå ùó°ùóº ùòÄùòÇùó∞ùóµ ùòÇùòÄùó≤ùóø ùó≥ùóºùòÇùóªùó± ùó∂ùóª ùó±ùóÆùòÅùóÆùóØùóÆùòÄùó≤!\n\nID: `{specific_user_id}`",
                    reply_to_message_id=message.id
                )
                return

            if user_data.get("plan", {}).get("type") != "premium":

                await fetching_msg.delete()
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"‚ùå ùóßùóµùó≤ ùòÇùòÄùó≤ùóø ùó±ùóºùó≤ùòÄ ùóªùóºùòÅ ùóµùóÆùòÉùó≤ ùóÆùóª ùóÆùó∞ùòÅùó∂ùòÉùó≤ ùóΩùóøùó≤ùó∫ùó∂ùòÇùó∫ ùóΩùóπùóÆùóª.\n\nID: `{specific_user_id}`",
                    reply_to_message_id=message.id,
                    disable_web_page_preview=True
                )
                return

            premium_users = [user_data]
        else:
            premium_users = await database.users.find({
                'plan.type': 'premium',
                'plan.preset': {
                    '$not': {'$regex': '^token_'}
                }
            }).to_list(length=None)

        if not premium_users:
            await fetching_msg.delete()
            await client.send_message(chat_id=message.chat.id, text="‚ö†Ô∏è ùó°ùóº ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ ùóôùóºùòÇùóªùó±!", reply_to_message_id=message.id)
            return

        ist = pytz.timezone("Asia/Kolkata")
        now_utc = datetime.now(pytz.utc)
        semaphore = asyncio.Semaphore(20)

        async def process_user(user):
            async with semaphore:
                try:
                    user_id = user['user_id']
                    plan = user.get("plan", {})
                    premium_started = plan.get("started_at")
                    premium_expiration = plan.get("expiration_at")
                    existing_preset = plan.get('preset') or "Custom"
                    admin_id = plan.get("upgrade_by")

                    if isinstance(premium_started, str):
                        premium_started = datetime.fromisoformat(premium_started).replace(tzinfo=pytz.utc)
                    elif premium_started and premium_started.tzinfo is None:
                        premium_started = premium_started.replace(tzinfo=pytz.utc)

                    if isinstance(premium_expiration, str):
                        premium_expiration = datetime.fromisoformat(premium_expiration).replace(tzinfo=pytz.utc)
                    elif premium_expiration is not None and premium_expiration.tzinfo is None:
                        premium_expiration = premium_expiration.replace(tzinfo=pytz.utc)

                    started_time_ist = premium_started.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)" if premium_started else "N/A"
                    expiry_time_ist = "Never" if not premium_expiration else \
                        f"`{premium_expiration.astimezone(ist).strftime('%d %B, %Y - %I:%M:%S %p')}` (IST)"

                    if premium_expiration:
                        remaining_time_str = format_duration(premium_expiration - now_utc)
                    else:
                        remaining_time_str = "‚ôæÔ∏è Lifetime"

                    if premium_started and premium_expiration:
                        plan_validity_str = format_duration(premium_expiration - premium_started)
                    else:
                        plan_validity_str = "‚ôæÔ∏è Lifetime"
                    try:
                        user_info = await client.get_users(user_id)
                        user_mention = f"[{user_info.first_name}](tg://user?id={user_id})"
                    except Exception:
                        user_mention = f"`{user_id}`"
                    
                    try:
                        admin_info = await client.get_users(admin_id)
                        admin_mention = f"[{admin_info.first_name}](tg://user?id={admin_id})"
                    except Exception:
                        admin_mention = f"`{admin_id}`"

                    return (
                        f"üë§ ùó®ùòÄùó≤ùóø: {user_mention}\n"
                        f"‚ö° ùó®ùòÄùó≤ùóø ùóúùóó: `{user_id}`\n"
                        f"üìÜ ùó£ùóπùóÆùóª: `{existing_preset}`, *{plan_validity_str}*\n"
                        f"‚è≥ ùó¶ùòÅùóÆùóøùòÅùó≤ùó± ùóßùó∂ùó∫ùó≤: {started_time_ist}\n"
                        f"‚åõ ùóòùòÖùóΩùó∂ùóøùòÜ ùóßùó∂ùó∫ùó≤: {expiry_time_ist}\n"
                        f"üïí ùóßùó∂ùó∫ùó≤ ùóπùó≤ùó≥ùòÅ: {remaining_time_str}\n"
                        f"ü§ç ùó®ùóΩùó¥ùóøùóÆùó±ùó≤ ùóïùòÜ: {admin_mention}\n"
                        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
                    )
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå {e}")
                    return None

        tasks = [process_user(user) for user in premium_users]
        results = await asyncio.gather(*tasks)
        user_list = [r for r in results if r]

        await fetching_msg.delete()  # Delete the "Fetching..." message

        result_text = f"üëë ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ [ùóßùóºùòÅùóÆùóπ: {len(user_list)}]\n\n" + "\n".join(user_list)
        if len(result_text) <= 4096:
            await client.send_message(
                chat_id=message.chat.id,
                text=result_text,
                reply_to_message_id=message.id,
                disable_web_page_preview=True
            )
        else:
            try:
                html_text = result_text.replace("\n", "<br>")
                page = telegraph.create_page(
                    title="Premium Users List",
                    html_content=html_text
                )
                link = f"https://telegra.ph/{page['path']}"
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"**üìÑ Premium User List.\n\nView here: [View]({link})**",
                    reply_to_message_id=message.id,
                    disable_web_page_preview=True
                )
            except Exception:
                file_path = f"Premium_Users_{int(time.time())}.txt"
                async with aiofiles.open(file_path, "w", encoding="utf-8") as f:
                    await f.write(result_text)

                await client.send_document(
                    chat_id=message.chat.id,
                    document=file_path,
                    caption="**üìÑ Premium User List**",
                    reply_to_message_id=message.id
                )
                os.remove(file_path)

    except Exception as e:
        try:
            await fetching_msg.delete()
        except:
            pass
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )


#Remove User From Premium
@Client.on_message(filters.command("remove") & filters.private, group=3)
async def remove_premium(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        # Extract user ID from the command
        command = message.text.split()
        if len(command) != 2:
            await client.send_message(message.chat.id, "‚ùó **Usage:** `/remove user_id`", reply_to_message_id=message.id)
            return

        # Validate user_id as an integer
        user_id = command[1]
        if not user_id.isdigit():
            await client.send_message(message.chat.id, "**Invalid input. User ID must be a valid number.**", reply_to_message_id=message.id)
            return

        user_id = int(user_id)  # Convert user_id to integer after validation

        # Check if the user exists in the database
        user = await database.users.find_one({'user_id': user_id})
        if user is None:
            await client.send_message(message.chat.id, f"**‚ùå User ID {user_id} not found in the database.**", reply_to_message_id=message.id)
            return
        
        # Check If User Free Don't remove 
        if not user or user.get("plan", {}).get("type") != "premium":
            await client.send_message(message.chat.id, f"**‚ùå User ID {user_id} doesn't have a active premium plan.**", reply_to_message_id=message.id)
            return
        
        # Fetch user details for mention
        user_info = await client.get_users(user_id)

        # Update user plan to "free" and set premium_expiration to None
        await database.users.update_one(
            {'user_id': user_id},
            {
              '$set': {
                'plan.type': 'free',
                'plan.started_at': None,
                'plan.expiration_at': None,
                'stop_status': True
              },
              '$unset': {
                'plan.preset': None,
                'plan.upgrade_by': None
              }
            }
        )

        # Notify admin
        await client.send_message(
            chat_id=message.chat.id,
            text=f"**Premium removed successfully ‚úÖ**\n\n"
                 f"üë§ **User:** [{user_info.first_name}](tg://user?id={user_info.id})\n"
                 f"‚ö° **User ID:** `{user_id}`\n\n"
                 f"**User is now on the free plan.**",
            reply_to_message_id=message.id,
            disable_web_page_preview=True
        )
        
        # Notify the user
        await client.send_message(
            chat_id=user_id,
            text=f"üëã Hi [{user_info.first_name}](tg://user?id={user_info.id}),\n"
                 f"**Your premium plan has been removed.**\n"
                 f"**You are now on the free plan.**",
            disable_web_page_preview=True
        )

    except Exception as e:
        await client.send_message(chat_id=message.chat.id, text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`", reply_to_message_id=message.id)




# Broadcast
@Client.on_message(filters.command("broadcast") & filters.private, group=3)
async def broadcast_message(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        total_users = await database.users.count_documents({})
        if total_users == 0:
            await client.send_message(
                chat_id=message.chat.id,  
                text="‚ö†Ô∏è ùó°ùóº ùó®ùòÄùó≤ùóøùòÄ ùóôùóºùòÇùóªùó±!\n\nüí° There are currently **Zero Users** in the database. Try again later!",  
                reply_to_message_id=message.id
            )
            return

        all_users = await database.users.find().to_list(length=None)

        # Determine the broadcast content
        if message.reply_to_message:
            broadcast_from_chat = message.chat.id
            broadcast_message_id = message.reply_to_message.id
            broadcast_text = None
        else:
            parts = message.text.split(maxsplit=1)
            if len(parts) < 2:
                await client.send_message(
                    chat_id=message.chat.id,  
                    text="‚ÑπÔ∏è ùóõùóºùòÑ ùòÅùóº ùóïùóøùóºùóÆùó±ùó∞ùóÆùòÄùòÅ?\n\nüîπ Reply to a message to broadcast it.\nüîπ Or use `/broadcast Your Message Here`.",  
                    reply_to_message_id=message.id
                )
                return
            broadcast_text = parts[1]

        start_time = time.time()
        # Initialize counters
        sent_count = 0
        failed_count = 0
        blocked_count = 0
        deleted_count = 0
        blocked_user_ids = []
        deactivated_user_ids = []
        other_failed_user_ids = []


        # Send initial progress message:
        progress_message = await client.send_message(
            chat_id=message.chat.id,  
            text=(
            f"üöÄ ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùó¶ùóßùóîùó•ùóßùóòùóó!\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üë• ùóßùó¢ùóßùóîùóü ùó®ùó¶ùóòùó•ùó¶: `{total_users}`\n"
            f"‚úÖ ùóóùóòùóüùóúùó©ùóòùó•ùóòùóó: `0`\n"
            f"üö´ ùóïùóüùó¢ùóñùóûùóòùóó: `0`\n"
            f"üóëÔ∏è ùóóùóòùóüùóòùóßùóòùóó: `0`\n"
            f"‚ùå ùóôùóîùóúùóüùóòùóó: `0`\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"‚è≥ *ùó£ùó•ùó¢ùóñùóòùó¶ùó¶ùóúùó°ùóö...*"
            ),
            reply_to_message_id=message.id
        )
        
        # Limit concurrent tasks to avoid flooding (e.g., 20 at a time)
        semaphore = asyncio.Semaphore(20)

        # Define a helper coroutine to send the message for a single user
        async def send_to_user(user):
            nonlocal sent_count, failed_count, blocked_count, deleted_count
            user_id = user["user_id"]
            async with semaphore:
                try:
                    if message.reply_to_message:
                        await client.copy_message(
                            chat_id=user_id,
                            from_chat_id=broadcast_from_chat,
                            message_id=broadcast_message_id
                        )
                    else:
                        await client.send_message(chat_id=user_id, text=broadcast_text)
                    sent_count += 1
                except UserIsBlocked:
                    blocked_count += 1
                    blocked_user_ids.append(user_id)
                except PeerIdInvalid:
                    deleted_count += 1
                    deactivated_user_ids.append(user_id)
                    await database.users.delete_one({"user_id": user_id})
                except Exception:
                    failed_count += 1
                    other_failed_user_ids.append(user_id)
                await asyncio.sleep(0.1)

        # Create and launch tasks concurrently
        tasks = [asyncio.create_task(send_to_user(user)) for user in all_users]

        # Optionally, update progress periodically while tasks are running.
        # For example, update every 2 seconds until all tasks are complete:
        async def update_progress():
            while any(not task.done() for task in tasks):
                await progress_message.edit_text(
                    f"üì° ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóßùóúùó°ùóö...\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üë• ùóßùó¢ùóßùóîùóü ùó®ùó¶ùóòùó•ùó¶: `{total_users}`\n"
                    f"‚úÖ ùóóùóòùóüùóúùó©ùóòùó•ùóòùóó: `{sent_count}`\n"
                    f"üö´ ùóïùóüùó¢ùóñùóûùóòùóó: `{blocked_count}`\n"
                    f"üóëÔ∏è ùóóùóòùóüùóòùóßùóòùóó: `{deleted_count}`\n"
                    f"‚ùå ùóôùóîùóúùóüùóòùóó: `{failed_count}`\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üîÑ *ùó£ùó•ùó¢ùóñùóòùó¶ùó¶ùóúùó°ùóö...*"
                )
                await asyncio.sleep(2)

        progress_updater = asyncio.create_task(update_progress())

        # Wait for all sending tasks to complete
        await asyncio.gather(*tasks)
        progress_updater.cancel()  # stop the progress updater
        await progress_message.delete()

        # Compute success and failure rates
        success_rate = (sent_count / total_users) * 100 if total_users > 0 else 0
        failure_rate = ((failed_count + blocked_count + deleted_count) / total_users) * 100 if total_users > 0 else 0
        
        end_time = time.time()
        total_seconds = int(end_time - start_time)

        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)

        if hours:
            duration = f"{hours} hour{'s' if hours != 1 else ''} {minutes} min {seconds} sec"
        elif minutes:
            duration = f"{minutes} min {seconds} sec"
        else:
            duration = f"{seconds} sec"

        # Final completion message
        await client.send_message(
            chat_id=message.chat.id,
            text=(
                f"üéØ ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùóñùó¢ùó†ùó£ùóüùóòùóßùóò!\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üë• ùóßùó¢ùóßùóîùóü ùó®ùó¶ùóòùó•ùó¶: `{total_users}`\n"
                f"‚úÖ ùó¶ùó®ùóñùóñùóòùó¶ùó¶: `{sent_count}`\n"
                f"üö´ ùóïùóüùó¢ùóñùóûùóòùóó: `{blocked_count}`\n"
                f"üóëÔ∏è ùóóùóòùóüùóòùóßùóòùóó: `{deleted_count}`\n"
                f"‚ùå ùóôùóîùóúùóüùó®ùó•ùóò: `{failed_count}`\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üìà ùó¶ùó®ùóñùóñùóòùó¶ùó¶ ùó•ùóîùóßùóò: `{success_rate:.2f}%`\n"
                f"üìâ ùóôùóîùóúùóüùó®ùó•ùóò ùó•ùóîùóßùóò: `{failure_rate:.2f}%`\n"
                f"‚è± ùóóùó®ùó•ùóîùóßùóúùó¢ùó°: `{duration}`\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üíñ *ùóßùóµùóÆùóªùó∏ ùòÜùóºùòÇ ùó≥ùóºùóø ùòÇùòÄùó∂ùóªùó¥ ùòÅùóµùó≤ ùóïùóøùóºùóÆùó±ùó∞ùóÆùòÄùòÅ ùóôùó≤ùóÆùòÅùòÇùóøùó≤!*"
            ),
            reply_to_message_id=message.id
        )

        broadcast_summary = [
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ùóïùó•ùó¢ùóîùóóùóñùóîùó¶ùóß ùó¶ùó®ùó†ùó†ùóîùó•ùó¨ üì£ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            f"üóìÔ∏è  Date & Time         : {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%d %B %Y - %I:%M:%S %p')}",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            f"üë•  Total Users         : {total_users}",
            f"‚úÖ  Successful          : {sent_count}",
            f"üö´  Blocked             : {blocked_count}",
            f"üóëÔ∏è  Deactivated/Invalid : {deleted_count}",
            f"‚ùå  Other Failures      : {failed_count}",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            f"üìà  Success Rate        : {success_rate:.2f}%",
            f"üìâ  Failure Rate        : {failure_rate:.2f}%",
            f"‚è±Ô∏è  Duration            : {duration}",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "",
            "üìõ ùóïùóπùóºùó∞ùó∏ùó≤ùó± ùó®ùòÄùó≤ùóø ùóúùóóùòÄ:",
            (", ".join(str(uid) for uid in blocked_user_ids) if blocked_user_ids else "None"),
            "",
            "üóëÔ∏è ùóóùó≤ùóÆùó∞ùòÅùó∂ùòÉùóÆùòÅùó≤ùó±/ùóúùóªùòÉùóÆùóπùó∂ùó± ùó®ùòÄùó≤ùóø ùóúùóóùòÄ:",
            (", ".join(str(uid) for uid in deactivated_user_ids) if deactivated_user_ids else "None"),
            "",
            "‚ö†Ô∏è ùó¢ùòÅùóµùó≤ùóø ùóôùóÆùó∂ùóπùó≤ùó± ùó®ùòÄùó≤ùóø ùóúùóóùòÄ:",
            (", ".join(str(uid) for uid in other_failed_user_ids) if other_failed_user_ids else "None"),
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "",
            "üíñ ùóßùóµùóÆùóªùó∏ ùòÜùóºùòÇ ùó≥ùóºùóø ùòÇùòÄùó∂ùóªùó¥ ùòÅùóµùó≤ ùóïùóøùóºùóÆùó±ùó∞ùóÆùòÄùòÅ ùóôùó≤ùóÆùòÅùòÇùóøùó≤!",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        ]
        file_path = f"Broadcast_Summary_{int(time.time())}.txt"
        async with aiofiles.open(file_path, "w", encoding="utf-8") as f:
            await f.write("\n".join(broadcast_summary))

        await client.send_document(
            chat_id=message.chat.id,
            document=file_path,
            caption="üìÑ *Detailed Broadcast Summary*"
        )

        os.remove(file_path)

    except Exception as e:
        await client.send_message(chat_id=message.chat.id, text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`", reply_to_message_id=message.id)




#Ban User
@Client.on_message(filters.command("ban") & filters.private, group=3)
async def ban_user(client: Client, message: Message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        cmd = message.text.split(maxsplit=2)
        if len(cmd) < 2:
            await client.send_message(
                message.chat.id,
                "‚ùó **Usage:** `/ban user_id [reason]`",
                reply_to_message_id=message.id
            )
            return

        try:
            user_id = int(cmd[1])
        except ValueError:
            await client.send_message(
                message.chat.id,
                "‚ùå **Invalid User ID!**",
                reply_to_message_id=message.id
            )
            return

        reason = cmd[2] if len(cmd) > 2 else "No reason provided."
        user = await database.users.find_one({"user_id": user_id})

        if not user:
            await client.send_message(
                message.chat.id,
                f"‚ùå **User ID `{user_id}` not found in the database.**",
                reply_to_message_id=message.id
            )
            return

        if user.get("banned_info", {}).get("status", False):
            banned_by_id = user['banned_info']['banned_by']
            try:
                admin_info = await client.get_users(banned_by_id)
                banned_by_mention = f"[{admin_info.first_name}](tg://user?id={banned_by_id})"
            except Exception:
                banned_by_mention = f"`{banned_by_id}`"

            ban_time = user['banned_info'].get('ban_time')
            if ban_time:
                ban_time_ist = ban_time.astimezone(pytz.timezone('Asia/Kolkata')).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)"
            else:
                ban_time_ist = "N/A"

            await client.send_message(
                message.chat.id,
                (
                    "‚ö†Ô∏è ùó™ùóµùóºùóÆ! ùóßùóµùó∂ùòÄ ùòÇùòÄùó≤ùóø ùó∂ùòÄ ùóÆùóπùóøùó≤ùóÆùó±ùòÜ ùóØùóÆùóªùóªùó≤ùó±!\n\n"
                    f"‚ö°Ô∏è **User ID:** `{user_id}`\n"
                    f"üìù **Reason:** `{user['banned_info']['reason']}`\n"
                    f"üìÖ **Banned On:** {ban_time_ist}\n"
                    f"üëÆ‚Äç‚ôÇÔ∏è **Banned By:** {banned_by_mention}"
                ),
                reply_to_message_id=message.id
            )
            return

        ban_time = datetime.now(pytz.utc)
        ban_time_ist = ban_time.astimezone(pytz.timezone('Asia/Kolkata')).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)"
        banned_by = message.from_user.id

        await database.users.update_one(
            {"user_id": user_id},
            {"$set": {
                "banned_info": {
                    "status": True,
                    "reason": reason,
                    "ban_time": ban_time,
                    "banned_by": banned_by
                }
            }},
            upsert=True
        )

        try:
            user_info = await client.get_users(user_id)
            user_mention = f"[{user_info.first_name}](tg://user?id={user_id})"
        except Exception:
            user_mention = f"`{user_id}`"

        admin_mention = f"[{message.from_user.first_name}](tg://user?id={banned_by})"

        await client.send_message(
            message.chat.id,
            (
                "üí• ùóïùóÆùóªùóªùó≤ùó± ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!\n\n"
                f"üë§ **User:** {user_mention}\n"
                f"‚ö°Ô∏è **User ID:** `{user_id}`\n"
                f"üìù **Reason:** `{reason}`\n"
                f"üìÖ **Ban Time:** {ban_time_ist}\n\n"
                f"*üö∑ ùóßùóµùó≤ ùòÇùòÄùó≤ùóø ùóµùóÆùòÄ ùóØùó≤ùó≤ùóª ùóØùóÆùóªùóªùó≤ùó± ùó≥ùóøùóºùó∫ ùòÇùòÄùó∂ùóªùó¥ ùòÅùóµùó≤ ùóØùóºùòÅ.*"
            ),
            reply_to_message_id=message.id
        )

        try:
            await client.send_message(
            user_id,
                (
                    "üö´ ùó¨ùóºùòÇ ùóõùóÆùòÉùó≤ ùóïùó≤ùó≤ùóª ùóïùóÆùóªùóªùó≤ùó±!\n\n"
                    f"üìÜ **Time**: {ban_time_ist}\n"
                    f"üìù **Reason**: `{reason}`\n\n"
                    "üîí ùó¨ùóºùòÇ ùó∞ùóÆùóª ùóªùóº ùóπùóºùóªùó¥ùó≤ùóø ùòÇùòÄùó≤ ùòÅùóµùó≤ ùóØùóºùòÅ.\n"
                    "‚ö†Ô∏è ùóñùóºùóªùòÅùóÆùó∞ùòÅ ùóÆùóª ùóÆùó±ùó∫ùó∂ùóª ùó∂ùó≥ ùòÅùóµùó∂ùòÄ ùòÑùóÆùòÄ ùóÆ ùó∫ùó∂ùòÄùòÅùóÆùó∏ùó≤."
                )
            )
        except:
            pass

    except Exception as e:
        await client.send_message(
            message.chat.id,
            f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )


#Banned Users List
@Client.on_message(filters.command("count_banned") & filters.private, group=3)
async def count_banned(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        fetching_msg = await client.send_message(
            chat_id=message.chat.id,
            text="‚è≥ ùóôùó≤ùòÅùó∞ùóµùó∂ùóªùó¥ ùóØùóÆùóªùóªùó≤ùó± ùòÇùòÄùó≤ùóøùòÄ, ùóΩùóπùó≤ùóÆùòÄùó≤ ùòÑùóÆùó∂ùòÅ...",
            reply_to_message_id=message.id
        )

        if len(message.command) > 1:
            arg = message.command[1].strip()
            if not arg.isdigit():
                await fetching_msg.delete()
                return await client.send_message(
                    chat_id=message.chat.id,
                    text="‚ö†Ô∏è ùóòùóøùóøùóºùóø:\n\nPlease provide a **valid numeric user ID**.",
                    reply_to_message_id=message.id
                )
            specific_user_id = int(arg)

            user_data = await database.users.find_one({'user_id': specific_user_id})
            if not user_data:
                await fetching_msg.delete()
                return await client.send_message(
                    chat_id=message.chat.id,
                    text=f"‚ùå ùó°ùóº ùòÄùòÇùó∞ùóµ ùòÇùòÄùó≤ùóø ùó≥ùóºùòÇùóªùó±!\n\nID: `{specific_user_id}`",
                    reply_to_message_id=message.id
                )

            if not user_data.get("banned_info", {}).get("status", False):
                await fetching_msg.delete()
                return await client.send_message(
                    chat_id=message.chat.id,
                    text=f"‚ùå ùóßùóµùó∂ùòÄ ùòÇùòÄùó≤ùóø ùó∂ùòÄ ùóªùóºùòÅ ùóØùóÆùóªùóªùó≤ùó±.\n\nID: `{specific_user_id}`",
                    reply_to_message_id=message.id
                )

            banned_users = [user_data]
        else:
            banned_users = await database.users.find({"banned_info.status": True}).to_list(length=None)

        if not banned_users:
            await fetching_msg.delete()
            return await client.send_message(
                chat_id=message.chat.id,
                text="‚úÖ ùó°ùóº ùóØùóÆùóªùóªùó≤ùó± ùòÇùòÄùó≤ùóøùòÄ ùó≥ùóºùòÇùóªùó±.",
                reply_to_message_id=message.id
            )

        ist = pytz.timezone("Asia/Kolkata")
        semaphore = asyncio.Semaphore(20)

        async def format_user(user):
            async with semaphore:
                try:
                    user_id = user.get("user_id")
                    info = user.get("banned_info", {})
                    reason = info.get("reason", "No reason provided.")
                    ban_time = info.get("ban_time", None)
                    banned_by = info.get("banned_by", "Unknown")

                    # Format ban time
                    try:
                        ban_dt_ist = ban_time.astimezone(ist)
                        ban_time_ist = ban_dt_ist.strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)"
                        time_passed = datetime.now(ist) - ban_dt_ist
                        passed_str = f"{time_passed.days}d, {time_passed.seconds//3600}h, {(time_passed.seconds//60)%60}m"
                    except Exception as e:
                        logger.error(f"Error: {e}")
                        ban_time_ist = "`N/A`"
                        passed_str = "N/A"

                    try:
                        user_info = await client.get_users(user_id)
                        user_mention = f"[{user_info.first_name}](tg://user?id={user_id})"
                    except:
                        user_mention = f"`{user_id}`"

                    try:
                        admin_info = await client.get_users(banned_by)
                        admin_mention = f"[{admin_info.first_name}](tg://user?id={banned_by}) (`{banned_by}`)"
                    except:
                        admin_mention = f"`{banned_by}`"

                    return (
                        f"üë§ ùó®ùòÄùó≤ùóø: {user_mention}\n"
                        f"‚ö°Ô∏è ùó®ùòÄùó≤ùóø ùóúùóó: `{user_id}`\n"
                        f"üìù ùó•ùó≤ùóÆùòÄùóºùóª: `{reason}`\n"
                        f"üìÖ ùóïùóÆùóªùóªùó≤ùó± ùó¢ùóª: {ban_time_ist}\n"
                        f"‚è≥ ùóßùó∂ùó∫ùó≤ ùó¶ùó∂ùóªùó∞ùó≤ ùóïùóÆùóª: `{passed_str}`\n"
                        f"üëÆ‚Äç‚ôÇÔ∏è ùóïùóÆùóªùóªùó≤ùó± ùóïùòÜ: {admin_mention}\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    )
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå {e}")
                    return None

        results = await asyncio.gather(*(format_user(u) for u in banned_users))
        filtered = [r for r in results if r]

        await fetching_msg.delete()

        final_text = f"üö´ ùóïùóÆùóªùóªùó≤ùó± ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ [ùóßùóºùòÅùóÆùóπ: {len(filtered)}]\n\n" + "\n".join(filtered)

        if len(final_text) <= 4096:
            await client.send_message(
                chat_id=message.chat.id,
                text=final_text,
                reply_to_message_id=message.id,
                disable_web_page_preview=True
            )
        else:
            try:
                html_text = final_text.replace("\n", "<br>")
                page = telegraph.create_page(
                    title="Banned Users List",
                    html_content=html_text
                )
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"üìÑ ùóïùóÆùóªùóªùó≤ùó± ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ\n\nùó©ùó∂ùó≤ùòÑ ùóºùóª [ùóßùó≤ùóπùó≤ùó¥ùóøùóÆùóΩùóµ]({page['url']})",
                    reply_to_message_id=message.id,
                    disable_web_page_preview=True
                )
            except:
                file_path = f"Banned_Users_{int(time.time())}.txt"
                async with aiofiles.open(file_path, "w", encoding="utf-8") as f:
                    await f.write(final_text)

                await client.send_document(
                    chat_id=message.chat.id,
                    document=file_path,
                    caption="üìÑ ùóïùóÆùóªùóªùó≤ùó± ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ",
                    reply_to_message_id=message.id
                )
                os.remove(file_path)

    except Exception as e:
        try: await fetching_msg.delete()
        except: pass
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )


#Unban User
@Client.on_message(filters.command("unban") & filters.private, group=3)
async def unban_user(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        cmd = message.text.split(maxsplit=1)
        if len(cmd) < 2:
            await client.send_message(
                chat_id=message.chat.id,
                text="‚ùó ùó®ùòÄùóÆùó¥ùó≤:\n\n`/unban user_id`",
                reply_to_message_id=message.id
            )
            return

        user_id = cmd[1].strip()
        if not user_id.isdigit():
            await client.send_message(
                chat_id=message.chat.id,
                text="‚ùå ùóúùóªùòÉùóÆùóπùó∂ùó± ùó®ùòÄùó≤ùóø ùóúùóó!\n\nPlease provide a valid numeric ID.",
                reply_to_message_id=message.id
            )
            return
        user_id = int(user_id)

        user = await database.users.find_one({"user_id": user_id})
        if not user:
            await client.send_message(
                message.chat.id,
                f"‚ùå ùó®ùòÄùó≤ùóø ùóúùóó `{user_id}` ùóªùóºùòÅ ùó≥ùóºùòÇùóªùó± ùó∂ùóª ùóºùòÇùóø ùó±ùóÆùòÅùóÆùóØùóÆùòÄùó≤.",
                reply_to_message_id=message.id
            )
            return

        if not user.get("banned_info", {}).get("status", False):
            await client.send_message(
                message.chat.id,
                f"‚ÑπÔ∏è ùó®ùòÄùó≤ùóø `{user_id}` ùó∂ùòÄ ùóªùóºùòÅ ùóØùóÆùóªùóªùó≤ùó±.",
                reply_to_message_id=message.id
            )
            return


        await database.users.update_one(
            {"user_id": user_id},
            {"$unset": {"banned_info": ""}}
        )

        try:
            user_info = await client.get_users(user_id)
            user_mention = f"[{user_info.first_name}](tg://user?id={user_id})"
        except Exception:
            user_mention = f"`{user_id}`"

        admin_mention = f"[{message.from_user.first_name}](tg://user?id={message.from_user.id})"

        await client.send_message(
            chat_id=message.chat.id,
            text=(
                "‚úÖ ùó®ùóªùóØùóÆùóªùóªùó≤ùó± ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ!\n\n"
                f"üë§ **User:** {user_mention}\n"
                f"‚ö°Ô∏è **User ID:** `{user_id}`\n\n"
                "*üîì ùóßùóµùó≤ ùòÇùòÄùó≤ùóø ùó∞ùóÆùóª ùóªùóºùòÑ ùòÇùòÄùó≤ ùòÅùóµùó≤ ùóØùóºùòÅ ùóÆùó¥ùóÆùó∂ùóª.*"
            ),
            reply_to_message_id=message.id
        )

        try:
            await client.send_message(
                user_id,
                (
                    "üîì ùó¨ùóºùòÇ ùóõùóÆùòÉùó≤ ùóïùó≤ùó≤ùóª ùó®ùóªùóØùóÆùóªùóªùó≤ùó±!\n\n"
                    "‚úÖ ùó¨ùóºùòÇ ùó∞ùóÆùóª ùóªùóºùòÑ ùòÇùòÄùó≤ ùòÅùóµùó≤ ùóØùóºùòÅ ùóÆùòÄ ùóªùóºùóøùó∫ùóÆùóπ.\n"
                    "üéâ ùó™ùó≤ùóπùó∞ùóºùó∫ùó≤ ùóØùóÆùó∞ùó∏!"
                )
            )
        except:
            pass

    except Exception as e:
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )




#Token User List
@Client.on_message(filters.command("count_token") & filters.private, group=3)
async def count_token_users(client, message):
    try:
        if not await check_owner(client, message):
            return

        fetching_msg = await client.send_message(
            chat_id=message.chat.id,
            text="‚è≥ ùóôùó≤ùòÅùó∞ùóµùó∂ùóªùó¥ ùóßùóºùó∏ùó≤ùóª ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ...",
            reply_to_message_id=message.id
        )

        token_users = await database.users.find({
            'plan.type': 'premium',
            'plan.preset': {'$regex': '^token_'}
        }).to_list(length=None)

        total_tokens_used = await database.tokens.count_documents({'status': 'used'})
        ist = pytz.timezone("Asia/Kolkata")
        now_utc = datetime.now(pytz.utc)
        semaphore = asyncio.Semaphore(20)

        async def process_user(user):
            async with semaphore:
                try:
                    user_id = user['user_id']
                    plan = user.get("plan", {})
                    preset = plan.get("preset", "Unknown")
                    started = plan.get("started_at")
                    expires = plan.get("expiration_at")

                    if isinstance(started, str):
                        started = datetime.fromisoformat(started).replace(tzinfo=pytz.utc)
                    elif started and started.tzinfo is None:
                        started = started.replace(tzinfo=pytz.utc)

                    if isinstance(expires, str):
                        expires = datetime.fromisoformat(expires).replace(tzinfo=pytz.utc)
                    elif expires and expires.tzinfo is None:
                        expires = expires.replace(tzinfo=pytz.utc)

                    start_ist = started.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)" if started else "N/A"
                    expire_ist = expires.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)" if expires else "‚ôæÔ∏è Lifetime"

                    validity = format_duration(expires - started) if started and expires else "‚ôæÔ∏è Lifetime"
                    remaining = format_duration(expires - now_utc) if expires else "‚ôæÔ∏è Lifetime"

                    token_count = await database.tokens.count_documents({'used_by': user_id})

                    try:
                        user_info = await client.get_users(user_id)
                        mention = f"[{user_info.first_name}](tg://user?id={user_id})"
                    except:
                        mention = f"`{user_id}`"

                    return (
                        f"üë§ ùó®ùòÄùó≤ùóø: {mention}\n"
                        f"üÜî ùó®ùòÄùó≤ùóø ID: `{user_id}`\n"
                        f"üéüÔ∏è ùóßùóºùó∏ùó≤ùóª: `{preset}`\n"
                        f"üìÖ ùó¶ùòÅùóÆùóøùòÅùó≤ùó±: {start_ist}\n"
                        f"üìÜ ùóòùòÖùóΩùó∂ùóøùó≤ùòÄ: {expire_ist}\n"
                        f"‚åõÔ∏è ùó©ùóÆùóπùó∂ùó±ùó∂ùòÅùòÜ: {validity}\n"
                        f"‚è≥ ùóßùó∂ùó∫ùó≤ ùóüùó≤ùó≥ùòÅ: {remaining}\n"
                        f"üì¶ ùóßùóºùó∏ùó≤ùóªùòÄ ùó®ùòÄùó≤ùó±: `{token_count}`\n"
                        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
                    )
                except Exception as e:
                    logger.error(f"Error token user: {e}")
                    return None

        results = await asyncio.gather(*(process_user(u) for u in token_users))
        results = [r for r in results if r]

        await fetching_msg.delete()

        full_text = (
            f"‚úÖ ùóßùóºùòÅùóÆùóπ ùóßùóºùó∏ùó≤ùóªùòÄ ùó®ùòÄùó≤ùó± (ùó¢ùòÉùó≤ùóøùóÆùóπùóπ): `{total_tokens_used}`\n"
            f"üéüÔ∏è ùóßùóºùó∏ùó≤ùóª ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ [ùóßùóºùòÅùóÆùóπ: {len(results)}]\n\n"
            + "\n".join(results)
        )

        if len(full_text) <= 4096:
            await client.send_message(
                chat_id=message.chat.id,
                text=full_text,
                reply_to_message_id=message.id,
                disable_web_page_preview=True
            )
        else:
            try:
                html = full_text.replace("\n", "<br>")
                page = telegraph.create_page("Token Premium Users", html)
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"üìÑ ùóßùóºùó∏ùó≤ùóª ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ: [ùó©ùó∂ùó≤ùòÑ](https://telegra.ph/{page['path']})",
                    reply_to_message_id=message.id,
                    disable_web_page_preview=True
                )
            except:
                path = f"Token_Users_{int(time.time())}.txt"
                async with aiofiles.open(path, "w") as f:
                    await f.write(full_text)
                await client.send_document(
                    chat_id=message.chat.id,
                    document=path,
                    caption="üìÑ ùóßùóºùó∏ùó≤ùóª ùó£ùóøùó≤ùó∫ùó∂ùòÇùó∫ ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ",
                    reply_to_message_id=message.id
                )
                os.remove(path)

    except Exception as e:
        logger.error(f"‚ùå Error in /count_token: {e}")
        try:
            await fetching_msg.delete()
        except:
            pass
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±:\n`{e}`",
            reply_to_message_id=message.id
        )



#All User List
@Client.on_message(filters.command("count_all") & filters.private, group=3)
async def check_all_users(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        fetching_msg = await client.send_message(
            chat_id=message.chat.id,
            text="‚è≥ ùóôùó≤ùòÅùó∞ùóµùó∂ùóªùó¥ ùóîùóπùóπ ùó®ùòÄùó≤ùóøùòÄ ùóúùóªùó≥ùóº, ùóΩùóπùó≤ùóÆùòÄùó≤ ùòÑùóÆùó∂ùòÅ...",
            reply_to_message_id=message.id
        )

        if len(message.command) > 1:
            arg = message.command[1].strip()
            if not arg.isdigit():
                await fetching_msg.delete()
                await client.send_message(
                    chat_id=message.chat.id,
                    text="‚ö†Ô∏è ùóòùóøùóøùóºùóø:\n\nPlease provide a **valid numeric user ID** only.",
                    reply_to_message_id=message.id
                )
                return
            specific_user_id = int(arg)

            user_data = await database.users.find_one({'user_id': specific_user_id})
            if not user_data:
                await fetching_msg.delete()
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"‚ùå ùó°ùóº ùòÄùòÇùó∞ùóµ ùòÇùòÄùó≤ùóø ùó≥ùóºùòÇùóªùó± ùó∂ùóª ùó±ùóÆùòÅùóÆùóØùóÆùòÄùó≤!\n\nID: `{specific_user_id}`",
                    reply_to_message_id=message.id
                )
                return

            all_users = [user_data]
        else:
            all_users = await database.users.find({}).to_list(length=None)

        if not all_users:
            await fetching_msg.delete()
            await client.send_message(chat_id=message.chat.id, text="‚ö†Ô∏è ùó°ùóº ùó®ùòÄùó≤ùóøùòÄ ùóôùóºùòÇùóªùó±!", reply_to_message_id=message.id)
            return

        ist = pytz.timezone("Asia/Kolkata")
        semaphore = asyncio.Semaphore(20)

        async def format_user(user):
            async with semaphore:
                try:
                    user_id = user.get("user_id")
                    registered_at = user.get("registered_at")
                    plan_info = user.get("plan", {})
                    plan_type = plan_info.get("type", "free")
                    preset = str(plan_info.get("preset", ""))
                    if plan_type == "premium" and preset.startswith("token_"):
                        type = "Token"
                    elif plan_type == "premium":
                        type = "Premium"
                    else:
                        type = "Free"

                    saved_files = user.get("saved_files", 0)
                    banned = user.get("banned_info", {}).get("status", False)

                    user_status = "‚õîÔ∏è ùóïùóÆùóªùóªùó≤ùó±" if banned else "‚úÖ ùóîùó∞ùòÅùó∂ùòÉùó≤"

                    # Format registration date
                    if registered_at:
                        if isinstance(registered_at, str):
                            registered_at = datetime.fromisoformat(registered_at)
                        if registered_at.tzinfo is None:
                            registered_at = pytz.utc.localize(registered_at)
                        registered_at = registered_at.astimezone(ist).strftime("`%d %B %Y - %I:%M:%S %p`") + " (IST)"
                    else:
                        registered_at = "N/A"

                    # Get user mention
                    try:
                        user_info = await client.get_users(user_id)
                        mention = f"[{user_info.first_name}](tg://user?id={user_id})"
                    except Exception:
                        mention = f"`{user_id}`"

                    return (
                        f"üë§ ùó®ùòÄùó≤ùóø: {mention}\n"
                        f"‚ö° ùó®ùòÄùó≤ùóø ùóúùóó: `{user_id}`\n"
                        f"üïì ùó•ùó≤ùó¥ùó∂ùòÄùòÅùó≤ùóøùó≤ùó±: {registered_at}\n"
                        f"üíñ ùóßùòÜùóΩùó≤: `{type}`\n"
                        f"üì• ùó¶ùóÆùòÉùó≤ùó± ùóôùó∂ùóπùó≤ùòÄ: `{saved_files}`\n"
                        f"üí† ùó¶ùòÅùóÆùòÅùòÇùòÄ: {user_status}\n"
                        "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
                    )
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå {e}")
                    return None

        tasks = [format_user(user) for user in all_users]
        results = await asyncio.gather(*tasks)
        user_infos = [r for r in results if r]

        await fetching_msg.delete()

        result_text = f"üìã ùóîùóπùóπ ùó•ùó≤ùó¥ùó∂ùòÄùòÅùó≤ùóøùó≤ùó± ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ [ùóßùóºùòÅùóÆùóπ: {len(user_infos)}]\n\n" + "\n".join(user_infos)

        if len(result_text) <= 4096:
            await client.send_message(
                chat_id=message.chat.id,
                text=result_text,
                reply_to_message_id=message.id,
                disable_web_page_preview=True
            )
        else:
            try:
                html_text = result_text.replace("`", "").replace("\n", "<br>")
                page = telegraph.create_page(
                    title="All Users List",
                    html_content=html_text
                )
                link = f"https://telegra.ph/{page['path']}"
                await client.send_message(
                    chat_id=message.chat.id,
                    text=f"üìÑ ùóîùóπùóπ ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ\n\nùó©ùó∂ùó≤ùòÑ ùóµùó≤ùóøùó≤: [ùóüùó∂ùóªùó∏]({link})",
                    reply_to_message_id=message.id,
                    disable_web_page_preview=True
                )
            except Exception:
                file_path = f"All_Users_{int(time.time())}.txt"
                async with aiofiles.open(file_path, "w", encoding="utf-8") as f:
                    await f.write(result_text)

                await client.send_document(
                    chat_id=message.chat.id,
                    document=file_path,
                    caption="üìÑ ùóîùóπùóπ ùó®ùòÄùó≤ùóøùòÄ ùóüùó∂ùòÄùòÅ",
                    reply_to_message_id=message.id
                )
                os.remove(file_path)

    except Exception as e:
        try:
            await fetching_msg.delete()
        except:
            pass
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )



#logs
@Client.on_message(filters.command("logs") & filters.private, group=3)
async def send_logs(client, message: Message):
    try:
        if not await check_owner(client, message):
            return

        log_file = "logs.txt"
        if not os.path.isfile(log_file):
            await message.reply_text("üö´ **Oops! Log file not found!\nPlease check the server..**", quote=True)
            return

        async with aiofiles.open(log_file, "r", encoding="utf-8", errors="ignore") as f:
            logs = await f.read()

        if not logs.strip():
            await message.reply_text("üì≠ **Log file is empty. Nothing to show.**", quote=True)
            return

        ist = pytz.timezone("Asia/Kolkata")
        timestamp = datetime.now(ist).strftime("%d %b %Y - %I:%M:%S %p")

        try:
            html_text = re.sub(r'[\ud800-\udfff]', '', logs).replace("\n", "<br>")[:38000]
            page = telegraph.create_page(
                title="üìò Bot Logs",
                html_content=html_text[:38000]  # Telegram Telegraph limit is ~40KB
            )

            log_url = f"https://telegra.ph/{page['path']}"
            await message.reply_text(
                text=(
                    "‚ú® **Your bot logs have been uploaded!**\n\n"
                    "üîç Click the button below to view them.\n\n"
                    f"üïí **Time:** `{timestamp}` (IST)\n"
                ),
                reply_markup=InlineKeyboardMarkup(
                    [[InlineKeyboardButton("üìÑ ùó©ùó∂ùó≤ùòÑ ùóüùóºùó¥ùòÄ", url=log_url)]]
                ),
                disable_web_page_preview=True,
                quote=True
            )
        except Exception as upload_err:
            logger.error(f"Telegraph error: {upload_err}")
            await client.send_document(
                chat_id=message.chat.id,
                document=log_file,
                caption=(
                    "üßæ **Bot Logs (Full File)**\n"
                    f"üïí **Fetched at:** `{timestamp}` (IST)"
                ),
                reply_to_message_id=message.id
            )

    except Exception as e:
        await message.reply_text(
            f"‚ö†Ô∏è **Error while fetching logs:**\n\n`{str(e)}`",
            quote=True
        )


# All User Stats
@Client.on_message(filters.command("stats"), group=4)
async def user_stats(client, message):
    try:
        # Owner Check: only allow authorized users
        if not await check_owner(client, message):
            return

        all_users = await database.users.find().to_list(length=None)
        total_users = len(all_users)

        banned_users = sum(1 for user in all_users if user.get('banned') is True)

        premium_users = 0
        token_users = 0

        for user in all_users:
            plan = user.get('plan', {})
            if plan.get('type') == 'premium':
                preset = str(plan.get('preset', ''))
                if preset.startswith('token_'):
                    token_users += 1
                else:
                    premium_users += 1

        free_users = total_users - premium_users - token_users
        total_downloads = sum(user.get('saved_files', 0) for user in all_users)

        msg = await client.send_message(
            chat_id=message.chat.id,
            text="**‚è≥ Fetching Info...**",
            reply_to_message_id=message.id
        )

        await msg.edit_text(
            "**‚ú® USER STATISTICS**\n\n"
            f"üë• **Total Users:** `{total_users}`\n"
            f"üíé **Premium Users:** `{premium_users}`\n"
            f"üîë **Token Users:** `{token_users}`\n"
            f"üÜì **Free Users:** `{free_users}`\n"
            f"‚õî **Banned Users:** `{banned_users}`\n"
            f"üì• **Total Saved:** `{total_downloads}`"
        )

    except Exception as e:
        await client.send_message(
            chat_id=message.chat.id,
            text=f"‚ö†Ô∏è ùóòùóøùóøùóºùóø ùó¢ùó∞ùó∞ùòÇùóøùóøùó≤ùó±!\n\n‚ùå `{e}`",
            reply_to_message_id=message.id
        )



# Token Info
@Client.on_message(filters.command("token_auth") & filters.private)
async def token_auth_command(client, message):
    if not await check_owner(client, message):
        return

    config_key = {"key": "Token_Info"}
    config = await database.config.find_one(config_key)

    # Set default config if missing
    if not config:
        config = {
            "key": "Token_Info",
            "token_mode": True,
            "api_url": TOKEN_API_URL,
            "api_key": TOKEN_API_KEY,
            "duration": 1,
            "auth_group_mode": False,
            "group_id": "‚ùå Not Set",
            "invite_link": "‚ùå Not Set"
        }
        await database.config.insert_one(config)

    await show_token_panel(client, message)


async def show_token_panel(client, message_or_callback):
    config = await database.config.find_one({"key": "Token_Info"}) or {}
    token_mode = config.get("token_mode", False)
    api_url = config.get("api_url", "‚ùå Not Set")
    api_key = config.get("api_key", "‚ùå Not Set")
    duration = config.get("duration", 1)
    auth_mode = config.get("auth_group_mode", False)
    group_id = config.get("group_id", "‚ùå Not Set")
    invite_link = config.get("invite_link", "‚ùå Not Set")

    try:
        group_name = (await client.get_chat(group_id)).title if isinstance(group_id, int) else "‚ùì Unknown"
    except:
        group_name = "‚ùì Unknown"

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"üîò Mode: {'‚úÖ ON' if token_mode else 'üö´ OFF'}", callback_data="TA_toggle_mode")],
        [
            InlineKeyboardButton("üåê Set API URL", callback_data="TA_set_api_url"),
            InlineKeyboardButton("üîë Set API Key", callback_data="TA_set_api_key"),
        ],
        [InlineKeyboardButton("‚è± Set Duration", callback_data="TA_set_duration")],
        [InlineKeyboardButton(f"üõ° Auth Group: {'‚úÖ ON' if auth_mode else 'üö´ OFF'}", callback_data="TA_toggle_auth")],
        [
            InlineKeyboardButton("üÜî Set Group ID", callback_data="TA_set_group_id"),
            InlineKeyboardButton("üîó Set Invite Link", callback_data="TA_set_invite_link"),
        ]
    ])

    text = (
        f"üõ†Ô∏è **Token Auth Configuration Panel**\n\n"
        f"üîò **Token Mode:** {'‚úÖ ON' if token_mode else 'üö´ OFF'}\n"
        f"üåê **API URL:** `{api_url}`\n"
        f"üîë **API Key:** `{api_key}`\n"
        f"‚è± **Duration:** `{duration}` hour(s)\n\n"
        f"üõ° **Auth Group Mode:** {'‚úÖ ON' if auth_mode else 'üö´ OFF'}\n"
        f"üìõ **Group Name:** `{group_name}`\n"
        f"üÜî **Group ID:** `{group_id}`\n"
        f"üîó **Invite Link:** {invite_link}"
    )

    # Send or edit based on source
    if isinstance(message_or_callback, CallbackQuery):
        await message_or_callback.message.edit_text(text, reply_markup=keyboard, disable_web_page_preview=True)
    else:
        msg_id = message_or_callback.reply_to_message.message_id if message_or_callback.reply_to_message else message_or_callback.id
        await client.send_message(
            message_or_callback.chat.id,
            text,
            reply_markup=keyboard,
            reply_to_message_id=msg_id,
            disable_web_page_preview=True
        )

@Client.on_callback_query(filters.regex(r"^TA_(.+)"), group=3)
async def token_auth_callback(client, callback):
    user_id = callback.from_user.id
    action = callback.data.split("_", 1)[1]
    config_key = {"key": "Token_Info"}
    config = await database.config.find_one(config_key) or {}

    if not await check_owner(client, callback):
        return

    async def ask_input(prompt: str):
        ask = await client.send_message(user_id, prompt)
        r = await client.listen(user_id)
        await ask.delete(), await r.delete()
        return r.text.strip()

    if action == "toggle_mode":
        await database.config.update_one(config_key, {"$set": {"token_mode": not config.get("token_mode", False)}}, upsert=True)
        await callback.answer("üîÑ Token Mode toggled!", show_alert=True)

    elif action == "toggle_auth":
        await database.config.update_one(config_key, {"$set": {"auth_group_mode": not config.get("auth_group_mode", False)}}, upsert=True)
        await callback.answer("üõ° Auth Group Mode Toggled!", show_alert=True)

    elif action == "set_api_url":
        text = await ask_input("üåê **Send new API URL:**\n\nSend `unset` to clear.")
        value = text if text != "unset" else "‚ùå Not Set"
        await database.config.update_one(config_key, {"$set": {"api_url": value}}, upsert=True)
        await callback.answer("‚úÖ API URL Updated!", show_alert=True)

    elif action == "set_api_key":
        text = await ask_input("üîë **Send new API Key:**\n\nSend `unset` to clear.")
        value = text if text != "unset" else "‚ùå Not Set"
        await database.config.update_one(config_key, {"$set": {"api_key": value}}, upsert=True)
        await callback.answer("‚úÖ API Key Updated!", show_alert=True)

    elif action == "set_duration":
        text = await ask_input("‚è± **Send Duration in hours (1-168):**")
        if text.isdigit() and 1 <= int(text) <= 168:
            await database.config.update_one(config_key, {"$set": {"duration": int(text)}}, upsert=True)
            await callback.answer("‚úÖ Duration Updated!", show_alert=True)
        else:
            await callback.answer("‚ùå Invalid duration!", show_alert=True)

    elif action == "set_group_id":
        text = await ask_input("üÜî **Send Group ID (starts with -100):**\n\nSend `unset` to clear.")
        if text == "unset":
            await database.config.update_one(config_key, {"$set": {"group_id": "‚ùå Not Set"}}, upsert=True)
            await callback.answer("‚úÖ Group ID cleared.", show_alert=True)
        elif text.startswith("-100") and text.lstrip("-").isdigit():
            await database.config.update_one(config_key, {"$set": {"group_id": int(text)}}, upsert=True)
            await callback.answer("‚úÖ Group ID Updated!", show_alert=True)
        else:
            await callback.answer("‚ùå Invalid Group ID!", show_alert=True)

    elif action == "set_invite_link":
        text = await ask_input("üîó **Send Invite Link:**\n\nSend `unset` to clear.")
        value = text if text != "unset" else "‚ùå Not Set"
        await database.config.update_one(config_key, {"$set": {"invite_link": value}}, upsert=True)
        await callback.answer("‚úÖ Invite Link Updated!", show_alert=True)

    await show_token_panel(client, callback)



async def check_owner(client: Client, event) -> bool:
    user_id = event.from_user.id

    if user_id not in OWNER_ID:
        if isinstance(event, Message):
            await client.send_message(
                chat_id=event.chat.id,
                text="üö´ ùóîùó∞ùó∞ùó≤ùòÄùòÄ ùóóùó≤ùóªùó∂ùó≤ùó±!\n\nüîí This command is **restricted** to bot admins.",
                reply_to_message_id=event.id
            )
        elif isinstance(event, CallbackQuery):
            await event.answer(
                "üö´ ùóîùó∞ùó∞ùó≤ùòÄùòÄ ùóóùó≤ùóªùó∂ùó≤ùó±!\n\nüîí This action is restricted to bot admins.",
                show_alert=True
            )
        return False
    return True